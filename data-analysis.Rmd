---
title: Traffic Data Analysis
output: html_document
---

```{r}
library(ggplot2)
library(dplyr)
library(knitr)
library(tidyr)
library(reshape2)
library(chron)

getmode <- function(v) {
   uniqv <- unique(v)
   uniqv[which.max(tabulate(match(v, uniqv)))]
}
```

# Data Processing

## Initialization

We first load our CSV file and take a glimpse at its contents.

```{r}
data.raw <- read.csv('all-semi-unique.csv')
glimpse(data.raw)
```

At first glance, we see that our raw data is composed of approximately 430k observations of 34 variables. Let us proceed to clean this data.

## Advertising data removal

Knowing that variables prefixed with **ad.** contain information relevant only to the application's advertising logic, we may safely drop them as they will not be used in our investigation.

```{r}
data.road <- data.raw %>%
  select(-(starts_with("ad.")))
```

## Removing constant valued columns

Now that we have dropped variables that will not be of interest, we can investigate for variables that always carry a constant value in our observations

```{r}
data.road %>%
  sapply(unique) %>%
  sapply(length)
```

We can spot two variables that are always constant: **rd.cl** and **rd.rp.type**. Since they add no information to our data, we may safely discard them. We then take note of the format the *crawl_date* variable is in.

```{r}
data.road <- data.road %>%
  select(-(rd.cl), -(rd.rp.type))
head(data.road$crawl_date)
```

## Crawl date format

The crawl_date column currently contains a factor of different strings. We proceed to parse this into a more machine readable format as a column of time values.

```{r}
data.road$crawl_date <-
  strptime(data.road$crawl_date, format = "%a %b %e %X UTC %Y", tz = "UTC") %>%
  as.POSIXct()
head(data.road$crawl_date)
```

## Report submission time estimation

Upon further inspection of bey2ollak.com's response data: **rd.rp.hr** and **rd.rp.mn** are the time differences between the crawl date and the report submission time. This means we can estimate the time of the response submission accurately down to a minute, which should be sufficient for our purposes. 

```{r}
data.road <- data.road %>%
  mutate(report_time = as.POSIXct(round(crawl_date - (rd.rp.hr*60*60 + rd.rp.mn*60), "mins"))) %>%
  select(-c(rd.rp.mn, rd.rp.hr))
```

## Road status update time estimation

**rd.hr** and **rd.mn** reflect how much time has passed since a road's status was updated on bey2ollak's end. We can extrapolate the last time a road's status was updated using similar means.

```{r}
data.road <- data.road %>%
  mutate(last_road_update = as.POSIXct(round(crawl_date - (rd.hr*60*60 + rd.mn*60), "mins"))) %>%
  select(-c(rd.mn, rd.hr))
```

## Road name split

We note that **rd.nm** contains a combination of the major road name and the minor road name. Splitting this column into two separate columns will help clarify more information about major roads and their minor segments.

```{r}
data.road <- data.road %>%
  separate(rd.nm, c("rd.majornm", "rd.minornm"), ";")
```

Some reports belong to a major road name as a whole with no minor road name. We proceed to replace the missing minor road names with a standard value.

```{r}
data.road$rd.minornm[is.na(data.road$rd.minornm)] <- "NO_MINOR"
```

We will now migrate the road names data to a different data frame in order to separate concerns.

```{r}
data.road_names <- data.road %>%
  select(rd.ri, rd.majornm, rd.minornm) %>%
  unique()
num_ids <- data.road_names %>%
  select(rd.ri) %>%
  unique() %>%
  nrow()
num_entries <- data.road_names %>% nrow()
num_ids == num_entries # # check for problems, expect TRUE
rm(num_ids, num_entries) # cleanup env

data.road <- data.road %>%
  select(-c(rd.majornm, rd.minornm))
```

## Extracting road status snapshots

Each crawl of the data represents a snapshot of all the road statuses at that time if we take the right perspective. Since every entry in our data is the road status data appended to some report data, we can isolate the road status information for analysis.

First, let us ensure that we have only a single rd.stid for each road per crawl.

```{r}
numberOfTripletsWithSTID <- data.road %>%
  select(crawl_date, rd.ri, rd.stid) %>%
  unique() %>%
  nrow()
numberOfTriplets <- data.road %>%
  select(crawl_date, rd.ri) %>%
  unique() %>%
  nrow()
numberOfTriplets == numberOfTripletsWithSTID # check for problems, expect TRUE
rm(numberOfTriplets, numberOfTripletsWithSTID) # cleanup env
```

We can now proceed to isolate road status snapshots knowing that taking unique pairs will not result in information loss.

```{r}
data.road.status <- data.road %>%
  select(crawl_date, rd.ri, rd.stid) %>%
  unique()
table(data.road.status$rd.stid)
```

Unfortunately, due to the way the data was crawled, there is an overwhelming amount of rows with **rd.stid** equal to 10 (info). This destroys the information conveyed by bey2olak about the road and renders this approach useless unless we attempt to approximate the correct congestion levels.

We choose discard the polluted column and attempt to follow a different approach. As we have also chosen to disregard the "snapshots" of road status, we may also discard the **crawl_date** and **last_road_update** columns.

```{r}
rm(data.road.status)
data.road <- data.road %>%
  select(-c(rd.stid, crawl_date, last_road_update)) %>%
  unique()
```

## Application-specific data elimination

We choose to discard **rd.new**, **rd.strq**, **rd.cmrq** and **rd.img** as they play a role in bey2ollak's application functionality and will not provide traffic insight.

```{r}
data.road <- data.road %>%
  select(-c(rd.new, rd.strq, rd.cmrq, rd.img)) %>%
  unique()
```

## User information

We choose not to do any analysis on user profiles, such as inspecting wether users with profile images/full names tend to be more or less active, and drop both the **rd.rp.fullnm** and **rd.rp.img** columns.

```{r}
data.road <- data.road %>%
  select(-c(rd.rp.fullnm, rd.rp.img)) %>%
  unique()
```

## Report time estimate errors

We are now in the position to partially account for some duplicates that result due to the error margin present in our report time estimates. We can remedy this by ignoring the possible *off-by-one* differences in **report_time** estimates resulting from our accruacy being limited to ± 1 minute.

```{r}
rpt_dupes <- data.road %>%
  select(-(report_time)) %>%
  duplicated()
data.road <- data.road %>%
  subset(!rpt_dupes)
rm(rpt_dupes)
```

## Extracting travel speeds

We will now attempt to extrapolate travel speeds so we can use them as the main metric later on in our analysis.

First, we will note that bey2ollak's auto report feature uses the following categorization for speed ranges:

Classification  | Speed Range  | rd.rp.stid 
--------------- | ------------ | -----------
7alawa          | 80+          | 1
lazeez          | 40-79        | 2
mashy           | 20-39        | 3
za7ma           | 10-19        | 4
mafeesh amal    | 0-9          | 5

The following rd.rp.stid values also correspond to different report types:

Type          | rd.rp.stid
------------- | -----------
so2al         | 6
khatar        | 7
7adsa         | 8
3otl          | 9
ba2ollak eh   | 10

A report can include both a congestion rating (7alawa - mafeesh 2amal) and/or a khatar/7adsa/3otl warning, or a report can be a so2al/ba2ollak eh. Unfortunately, the data crawling eliminated multiple <stid> tags and some information was lost. We can extract the questions since it is reasonable to assume they do not contribute to congestion level information.

```{r}
data.questions <- data.road %>%
  filter(rd.rp.stid == 6)
data.road <- data.road %>%
  filter(rd.rp.stid != 6)
data.road %>% nrow()
```

We will proceed to initially use the above classifications to approximate the value of a new column we will introduce which will represent average travel speed.

```{r}
data.road <- data.road %>%
  mutate(speed = NA)
data.road$speed[data.road$rd.rp.stid == 1] <- 85
data.road$speed[data.road$rd.rp.stid == 2] <- 60
data.road$speed[data.road$rd.rp.stid == 3] <- 30
data.road$speed[data.road$rd.rp.stid == 4] <- 15
data.road$speed[data.road$rd.rp.stid == 5] <- 5
data.road %>% select(speed) %>% is.na() %>% sum()
```

The automatic reporter produces templated comments containing our desired values. We can use these to fine tune our speed column values.

```{r}
library(stringr)
regexp <- "(\\d+ km/h)|(\\d+ كم/س)"
matched <- grepl(regexp, data.road$rd.rp.cm)

subs <- data.road$rd.rp.cm %>%
  subset(matched)
matches <- regmatches(subs, regexpr(regexp, subs))
data.road$speed[matched] <- gsub("\\D", " ", matches) %>%
  str_trim(side = "both") %>%
  as.integer()

rm(regexp, matched, subs, matches)

data.road %>% select(speed) %>% is.na() %>% sum()
```

Now we can isolate "ba2ollak eh" reports that do not contain any speed information. Furthermore, as the remaining NA values are randomly distributed across report_times, and are small in quantity relative to the remaining observation count, we will discard them.

```{r}
data.info <- data.road %>%
  filter(rd.rp.stid == 10 & is.na(speed))
data.road <- data.road %>%
  filter(!is.na(speed))
```

## Isolating Speed Reports

```{r}
data.speed <- data.road %>%
  select(rd.ri, rd.rp.cmid, report_time, speed) %>%
  rename(road = rd.ri, comment = rd.rp.cmid) %>%
  unique()
```

# Descriptive analysis

We are now left with a clean set of observations of approximate average travel speeds across different roads at different times.

```{r}
glimpse(data.speed)
```

## Data distribution across time

Our main concern in this report is not application usage analysis, but it will be useful to develop some insight into the distribution of our data points across our crawling timespan. This will help us identify any gaps in our knowledge of speed data.

```{r}
bins <- data.speed %>%
  split(cut(data.speed$report_time, "hour"))
sizes <- sapply(bins, nrow)
plot(sizes, type = "l")
```

We can observe from the above plot that our data is quite sparse in the first few days and in the last day of our crawl range. Therefore, we will focus our analysis on the two weeks from 07/02 until 21/02, where our data is not assumed to have gaps.

```{r}
left_boundary <- as.POSIXct(strptime("2016-02-07 04:00:00", "%F %X"), tz = "UTC")
right_boundary <- as.POSIXct(strptime("2016-02-21 04:00:00", "%F %X"), tz = "UTC")
data.speed <- data.speed %>%
  filter(report_time >= left_boundary, report_time < right_boundary)
```

```{r}
bins <- data.speed %>%
  split(cut(data.speed$report_time, "hour"))
sizes <- sapply(bins, nrow)
plot(sizes, type = "l")
```

We can now see some app usage patterns across weekdays and weekends.

## Isolated Analysis Procedure

Even though our data fits in memory, we have a plethora of information. Traffic flow data, even when only recorded sparsely for a couple of cities over two weeks, represents the ongoings of a very complex system with many intricacies that can not be summed up in a few global metrics. Therefore, we will carry out small practical analyses by isolating road segments.

```{r}
roadAnalysis <- function(segments, L = left_boundary, R = right_boundary) {
  focus <- data.speed %>%
    filter(report_time >= L, report_time < R)
  
  bins <- focus %>%
    split(cut(focus$report_time, "hour"))
  
  subs <- lapply(bins, function(bin) {
    tmp <- bin %>% 
      filter(road %in% segments) %>% 
      group_by(road) %>% 
      summarise(avg_spd = mean(speed))
    
    ord <- tmp[order(factor(tmp$road, levels = segments)),]
    
    entries <- nrow(tmp)
    
    if (entries == 0) {
      df <- data.frame(matrix(NA, ncol = 9, nrow = 1))
      names(df) <- segments
      return(df)
    }
    
    dframe <- data.frame(matrix(0, ncol = nrow(tmp), nrow = 1))
    names(dframe) <- ord$road
    dframe[1,] <- ord$avg_spd
    return(dframe)
  })
  
  dframe <- bind_rows(subs)
  dframe <- dframe[, as.character(segments)]
  row.names(dframe) <- names(subs)
  names(dframe) <- 1:9

  dmatrix <- data.matrix(dframe)
  return(dmatrix)
}

speedSegmentTimePlot <- function(dmatrix, segments) {
  tmp <- data.road_names %>% filter(rd.ri %in% segments)
  ord <- tmp[ order(factor(tmp$rd.ri, levels = segments)), "rd.minornm" ]
  
  return(
    ggplot(melt(dmatrix), aes(Var2, Var1, fill = value)) + 
      labs(x = "Segment", y = "Time", fill = "Avg. Km/h") +
      scale_x_continuous(breaks = 1:length(ord), labels = ord) +
      theme(axis.text.x = element_text(angle = 70, vjust = 0.5)) +
      geom_raster(interpolate = TRUE) +
      #scale_fill_gradientn(colours=c("#FF0000FF", "#00FF00FF", "#99FF00FF"))
      scale_fill_gradientn(
        colours=c("#DD2C2C", "#CE8827", "#DDD777", "#82C972", "#459B1A"),
        breaks = c(5, 15, 30, 60, 85))
  )
}
```

## Isolated Analysis - The Ring Road

The ring road is the major highway in Cairo. Bey2ollak segments it into the following parts:

ID   |   Segment
---- | ------------------------------
32   |          Moneeb To Autostrad
281  |     Autostrad To Sokhna Exit
315  |       Sokhna Exit To Tagamo3
316  |          Tagamo3 To Suez Rd.
302  |    Suez Rd. To Nafa2 ElSalam
285  |      Nafa2 ElSalam To Zera3y
286  |             Zera3y To Me7war
122  |   Me7war To Waslet Maryoutia
125  |   Waslet Maryoutia To Moneeb
---  |    **Opposite Direction**
126  |   Moneeb To Waslet Maryoutia
121  |   Waslet Maryoutia To Me7war
283  |             Me7war To Zera3y
284  |      Zera3y To Nafa2 ElSalam
301  |    Nafa2 ElSalam To Suez Rd.
317  |          Suez Rd. To Tagamo3
318  |       Tagamo3 To Sokhna Exit
282  |     Sokhna Exit To Autostrad
 31  |          Autostrad To Moneeb

Let's examine the speed patterns across place and time for the ring road.

### Clockwise direction

```{r fig.width=12, fig.height=10}
ring_road     <- c(31, 282, 318, 317, 301, 284, 283, 121, 126)

roadAnalysis(
  ring_road,
  as.POSIXct(strptime("2016-02-07 04:00:00", "%F %X"), tz = "UTC"),
  as.POSIXct(strptime("2016-02-14 04:00:00", "%F %X"), tz = "UTC")) %>%
  speedSegmentTimePlot(ring_road)
roadAnalysis(
  ring_road,
  as.POSIXct(strptime("2016-02-14 04:00:00", "%F %X"), tz = "UTC"),
  as.POSIXct(strptime("2016-02-21 04:00:00", "%F %X"), tz = "UTC")) %>%
  speedSegmentTimePlot(ring_road)
```

### Counter-clockwise direction

```{r fig.width=12, fig.height=10}
ring_road_ccw <- c(32, 281, 315, 316, 302, 285, 286, 122, 125)

roadAnalysis(
  ring_road_ccw,
  as.POSIXct(strptime("2016-02-07 04:00:00", "%F %X"), tz = "UTC"),
  as.POSIXct(strptime("2016-02-14 04:00:00", "%F %X"), tz = "UTC")) %>%
  speedSegmentTimePlot(ring_road_ccw)
roadAnalysis(
  ring_road_ccw,
  as.POSIXct(strptime("2016-02-14 04:00:00", "%F %X"), tz = "UTC"),
  as.POSIXct(strptime("2016-02-21 04:00:00", "%F %X"), tz = "UTC")) %>%
  speedSegmentTimePlot(ring_road_ccw)
```

## Travel speeds central tendencies and spreads

Let's carry out a different form of focused analysis on another road segment. First, we will need to differentiate between reports made on weekends and those made on weekdays. Then, we will combine the samples by the hours they were reported on in order to calculate an estimate of the true mean of travel speed at a given hour.

```{r}
data.speed <- data.speed %>%
  filter(speed < 150) # filter outliers (insane people/bugged reports)

data.speed$weekend <- data.speed$report_time %>% weekdays() %in% c("Friday", "Saturday")
data.speed$report_hour <- data.speed$report_time %>% hours() %>% factor(levels = 0:23, labels = 0:23)

average_speeds <- data.speed %>%
  group_by(road, weekend, report_hour) %>%
  summarise(mean = mean(speed), sd = sd(speed), median = median(speed), mode = getmode(speed), count = n()) %>%
  ungroup()

average_speeds %>%
  sample_n(size = 15) %>%
  kable()
```

In the spirit of focusing our analyses on single segments or cohesive sets of roads, let us take an excursion into the distribution of travel speeds on the following road segment represented by the following two road ids:

ID   |   Segment
---- | -----------------------------------
167  |  Ta7rir To Mohandesin
164  |  Mohandesin To Ta7rir

### Workdays

```{r}
data.speed %>%
  filter(road == 167, weekend == FALSE) %>% (function(x) {
  #boxplot(speed~report_hour, x, main = "Travel Speed Data", ylab = "Km/h", xlab = "Hour of day")
  qplot(report_hour, speed, data = x, geom = c("boxplot"))})
```

```{r}
data.speed %>%
  filter(road == 164, weekend == FALSE) %>% (function(x) {
  #boxplot(speed~report_hour, x, main = "Travel Speed Data", ylab = "Km/h", xlab = "Hour of day")
  qplot(report_hour, speed, data = x, geom = c("boxplot"))})
```

### Weekends

```{r}
data.speed %>%
  filter(road == 167, weekend == TRUE) %>% (function(x) {
  #boxplot(speed~report_hour, x, main = "Travel Speed Data", ylab = "Km/h", xlab = "Hour of day")
  qplot(report_hour, speed, data = x, geom = c("boxplot"))})
```

```{r}
data.speed %>%
  filter(road == 164, weekend == TRUE) %>% (function(x) {
  #boxplot(speed~report_hour, x, main = "Travel Speed Data", ylab = "Km/h", xlab = "Hour of day")
  qplot(report_hour, speed, data = x, geom = c("boxplot"))})
```

## Identifying key bottleneck points

## Speed tables

```{r}
speeds <- sapply(bins, function(x) {
    select(x, speed)
  })
avgs <- sapply(speeds, mean)
```

## Average Speed Correllations

Average speed of cars per road across time

Correlation of average speeds between roads


  
# Inferential analysis

# And beyond..

```{r}
glimpse(data.road)
glimpse(data.speed)
glimpse(data.road_names)
```